<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<script src="https://code.jquery.com/jquery-1.10.2.js"></script>
<script src="//code.jquery.com/ui/1.11.4/jquery-ui.js"></script>

</head>
<style>

body {
  overflow: hidden;
  width:100%;
  height:100%;
  cursor: move;
}


</style>
<body>

    <script src="three.min.js"></script>
    <script src="CSS3DRenderer.js"></script>

    <script>

      var camera, scene, renderer;
      var geometry, material, mesh;
      var target = new THREE.Vector3();

      var lon = 90, lat = 0;
      var phi = 0, theta = 0;

      var touchX, touchY;

      init();
      animate();
      
function init() {

        camera = new THREE.PerspectiveCamera( 100, window.innerWidth / window.innerHeight, 800, 200 );

        scene = new THREE.Scene();

        var sides = [
          {
            url: 'box.svg',
            position: [ 0, 0, -500 ],
            rotation: [ 0, Math.PI, 0 ]
          },
          {
            url: 'box.svg',
            position: [ 0, 0, 500 ],
            rotation: [ 0, 0, 0 ]
          },
          {
            url: 'box.svg',
            position: [ 500, 0, 0 ],
            rotation: [ 0, Math.PI/2, 0 ]
          },
          {
            url: 'box.svg',
            position: [ -500, 0, 0 ],
            rotation: [ 0, Math.PI/2, 0 ]
          }
        ];

        for ( var i = 0; i < sides.length; i ++ ) {

          var side = sides[ i ];

          var element = document.createElement( 'img' );
          element.width = 1000; 
          element.height = 10000; 
          element.src = side.url;

          var object = new THREE.CSS3DObject( element );
          object.position.fromArray( side.position );
          object.rotation.fromArray( side.rotation );
          scene.add( object );

        }

        renderer = new THREE.CSS3DRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        //

        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );

        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function onDocumentMouseDown( event ) {

        event.preventDefault();

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'mouseup', onDocumentMouseUp, false );

      }

      function onDocumentMouseMove( event ) {

        var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
        var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

        lon -= movementX * 0.9;
        lat += movementY * 0.9;

      }

      function onDocumentMouseUp( event ) {

        document.removeEventListener( 'mousemove', onDocumentMouseMove );
        document.removeEventListener( 'mouseup', onDocumentMouseUp );

      }

      function onDocumentMouseWheel( event ) {

        camera.fov -= event.wheelDeltaY * 0;
        camera.updateProjectionMatrix();

      }

      function onDocumentTouchStart( event ) {

        event.preventDefault();

        var touch = event.touches[ 0 ];

        touchX = touch.screenX;
        touchY = touch.screenY;

      }

      function onDocumentTouchMove( event ) {

        event.preventDefault();

        var touch = event.touches[ 0 ];

        lon -= ( touch.screenX - touchX ) * 0.5;
        lat += ( touch.screenY - touchY ) * 0.5;

        touchX = touch.screenX;
        touchY = touch.screenY;

      }

      function animate() {

        requestAnimationFrame( animate );

        lon +=  0.1;
        lat = Math.max( - 500, Math.min( 200, lat ) );
        phi = THREE.Math.degToRad( 90 - lat );
        theta = THREE.Math.degToRad( lon );

        target.x = Math.sin( phi ) * Math.cos( theta );
        target.y = Math.cos( phi );
        target.z = Math.sin( phi ) * Math.sin( theta );

        camera.lookAt( target );

        renderer.render( scene, camera );

      }
      
      </script>
      

  </body>



</html>